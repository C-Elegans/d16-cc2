%{
#include <stdio.h>
#include "ASTNode.hpp"
#include "ASTInclude.hpp"
#define YYDEBUG 1
extern int yylex();
extern int yyparse();
extern FILE* yyin;
extern int yyline;
void yyerror(const char* s);
ASTNode* ast;
%}

%union{
	char* sval;
	int ival;
	ASTNode* node;
	Operator_type o_type;
}
%token<sval> ID
%token<ival> NUM
%token ELSE IF INT RETURN VOID WHILE
%token PLUS MINUS MULTIPLY DIVIDE
%token CMP_EQUAL CMP_NEQUAL CMP_GREATER CMP_LESS CMP_GREATER_EQ CMP_LESS_EQ
%nonassoc NUM
%left CMP_EQUAL CMP_NEQUAL CMP_GREATER CMP_LESS CMP_GREATER_EQ CMP_LESS_EQ
%left PLUS MINUS
%left MULTIPLY DIVIDE

%type<node>program declaration_list declaration simple_expression term var expression
%type<node>expression_stmt selection_stmt statement return_stmt iteration_stmt
%type<o_type> operator
%start program
%%
program:
	statement {ast = $1;}
;
declaration_list:
		declaration_list declaration
	|	declaration
;
declaration:
	var_declaration | fun_declaration
;
var_declaration:
		type_specifier ID ';'
	|   type_specifier ID '[' NUM ']' ';'
;
type_specifier:
	INT | VOID
;
fun_declaration:
	type_specifier ID '(' params ')' compound_stmt
;
params:
	param_list | VOID
;
param_list:
		param_list ',' param
	|   param
;
param:
		type_specifier ID
	|	type_specifier ID '[' ']'
;
compound_stmt:
	'{' local_declarations statement_list '}'
;
local_declarations:
	local_declarations var_declaration
	| /* empty */
;
statement_list:
	statement_list statement
	| /* empty */
;

statement:
		expression_stmt
	//|	compound_stmt
	|	selection_stmt
	|	iteration_stmt
	|	return_stmt
;
expression_stmt:
	expression ';'{$$=$1;} | ';' {printf("empty expression\n");$$=nullptr;}
;
selection_stmt:
		IF '(' expression ')' statement {$$ = new Selection($3,$5);}
	|	IF '(' expression ')' statement ELSE statement {$$ = new Selection($3,$5,$7);}
;
iteration_stmt:
	WHILE '(' expression ')' statement {$$= new While($3,$5);}
;
return_stmt:
		RETURN ';' {$$=new Return();}
	|	RETURN expression ';' {$$=new Return($2);}
;
expression:
	var '=' simple_expression {$$=new Assign($1,$3);}
	| simple_expression	{$$=$1;}
;
var:
		ID  {$$=new Var($1);}
	|	ID '[' expression ']' {$$ = new Var($1,$3);}
;

simple_expression:
		simple_expression operator simple_expression {$$=new Operator($2,$1,$3);}
	|	term {$$=$1;}
;
operator:
	|	PLUS {$$=Operator_type::ADD;}
	|	MINUS {$$=Operator_type::SUBTRACT;}
	|	MULTIPLY {$$=Operator_type::MUL;}
	|	DIVIDE {$$=Operator_type::DIV;}
	|	CMP_EQUAL {$$=Operator_type::CMP_EQ;}
	|	CMP_NEQUAL {$$=Operator_type::CMP_NE;}
	|	CMP_GREATER {$$=Operator_type::CMP_GT;}
	|	CMP_LESS {$$=Operator_type::CMP_LT;}
	|	CMP_GREATER_EQ {$$=Operator_type::CMP_GE;}
	|	CMP_LESS_EQ {$$=Operator_type::CMP_LE;}
;
term:
		'(' expression ')' {$$=nullptr;}
	|	var {$$=new Eval($1);}
	|	call {$$=nullptr;}
	|	NUM {$$=new NumNode($1);}
;
call:
	ID '(' args ')'
;
args:
		args_list
	|	/* empty */
;
args_list:
		args_list ',' expression
	|	expression
;

%%
void yyerror(const char* s){
	fprintf(stderr, "Parse error on line %d: %s\n",yyline,s);
	exit(1);
}
